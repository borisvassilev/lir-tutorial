# Anagrams
By now we have covered all the basics of using Lir.
Finally, let's apply Lir to solve the problem of finding anagrams in the English language.
From here on, we move a bit faster, as there is less to explain.

We will implement the idea presented earlier: see [Aim](#aim) (this is a cross-reference to a section heading, as described in the [Pandoc manual](http://pandoc.org/MANUAL.html#header-identifiers).
Here is a diagram of the complete data flow of our implementation (data objects are written in small letters and DATA TRANSFORMATIONS are in all caps):
<<: Data flow for finding anagrams>>=
         +--< words >--+
         |             |
         |             |
       SIGN            |
         |             |
         v             |
    signatures         |
         v             |
         |             |
         +--> PASTE <--+
                v
                v
       SORT BY SIGNATURES
                v
                v
    +---< sorted-signed >---+
    |                       |
    |                       |
    v                       v
 COLUMN 1                COLUMN 2
    v                       v
    v                       |
COUNT RUNS                  |
    v                       |
    v           words-sorted-by-signature
 set-sizes                  |
    v                       |
    +-------> SQUASH <------+
                v
                v
           anagram-sets
@
The word "squash", as in "writing consecutive lines with the same signature to a space-separated list of anagrams on a line", comes from the discussion of this problem in "Programming Pearls" [@bentley1986programming].

To make this into a work flow that can be evaluated, we start by declaring the dependencies and rules:
<<:make>>=
en-signatures: sign.prolog en-words
	<<Run SWI-Prolog script>> $^ > $@

en-sorted-signed: paste-and-sort.sh en-signatures en-words
	bash $^ > $@

@
Note that here, we have put `PASTE` and `SORT BY SIGNATURES` from the diagram above in the same step, because there is no reason not to.

Similarly, we put `COLUMN 1` and `COUNT RUNS` in the same rule.
<<:make>>=
en-set-sizes: set-sizes.sh en-sorted-signed
	bash $^ > $@

en-words-sorted-by-signature: en-sorted-signed
	cut --field=2

@
Usually, avoid evaluating standard command line tools directly in the rules.
The reason is that if the rules change, Lir will not notice, because there is no executable code (code in non-special root chunks) that has changed.
In this isolated case, it is fine to leave it like this.
 
<<:make>>=
en-anagram-sets: squash en-set-sizes en-words-sorted-by-signature
	./$^ > $@

@
This is it!
This leaves us with a question: why didn't we generate the rules from the diagram, or the diagram from the rules?
Both are definitely doable, and probably not a bad idea; however, this would mean still more programs that would have to be involved in this work flow.
It is not in the scope of this tutorial, but a good exercise for the reader.

## Generate signatures
We need signatures such that words that are anagrams of each other have the same signature.
The approach we use here has been independently discovered by many programmers: if you sort the letters of two anagrams, you get the same result.

To generate the signatures, we use Prolog again.
This program opens for reading the file passed as its first command line argument, and writes all signatures to standard output:
<<sign.prolog>>=
main :-
        current_prolog_flag(argv, [Words_file|_]),
        setup_call_cleanup(open(Words_file, read, In),
                output_signatures(In, current_output),
                close(In)).
@

To output signatures, we [read from the input stream line by line](http://eu.swi-prolog.org/pldoc/doc_for?object=read_line_to_codes/2) (because each word is on a line of its own), sort the letters of the word [without removing duplicates](http://eu.swi-prolog.org/pldoc/doc_for?object=msort/2), and write the sorted letters to the output stream:
<<sign.prolog>>=
output_signatures(In, Out) :-
        read_line_to_codes(In, Word),
        (       Word == end_of_file
        ->      true
        ;       msort(Word, Signature),
                format(Out, "~s\n", [Signature]),
                output_signatures(In, Out)
        ).
@
This last code chunk is an example of a code chunk continuation.
If a code chunk with the same name already appeared earlier in the Lir source file, the contents will be appended to it.
Interrupting a code chunk like this is the Lir equivalent of a comment block within a source code file.

## Sort by signatures
This will be a Bash script that uses the standard command line tools `paste` and `sort`.
`Paste` will take two files with the same number of lines, and merge them in two columns separated by a tab.
We use `sort` with two options: `--key=1` says that it should sort by the value in the first column only, and `--stable` says that it sould ignore the rest of the line.
Because the second column is already sorted, adding the option `--stable` has no effect on the final result; however, it makes our intentions clear, and happens to do a bit less work (so it actually runs faster).
<<paste-and-sort.sh>>=
paste "$1" "$2" \
        | sort --key=1 --stable
@

## Anagram sets
First, we have to generate the size of each set of anagrams.
Because the file `en-sorted-signed` is sorted by signatures (its first column), it is enough to extract the first column and count the number of occurences of the same line.
For this, we use `cut` and `uniq --count`.

For reasons shouded in mistery, the output of `uniq --count` is a bit unconventional and cannot be configured.
Instead of using columns separated by a tab (or any other delimiter), it outputs the counts in a right-justified, space-padded column, separated from the next column with a single space.
We will use Awk to get the numbers only.
<<set-sizes.sh>>=
cut --fields=1 \
        | uniq --count \
        | awk '{ print $1 }'
@

Finally, we need a program that takes uses the set sizes and the words to squash sets of anagrams to lines.
All programs presented so far have been interpreted, without the additional step of compiling a source code file to an executable program.
For the sake of the example, the final program, `squash`, is implemented in C++.

It takes two arguments: the file with the counts, and the list of words.
