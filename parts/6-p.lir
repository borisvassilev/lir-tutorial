# How it's made
By now you should have some understanding of _what_ Lir does.  Now, we
will go into some detail on _how_ Lir does it.

If you have used Lir to interpret your Lir source file, there will be a
hidden directory `.lir` inside your working directory.  Go ahead and
delete `.lir` (you can use the command `rm -r .lir` to do that).  Don't
be afraid: nothing of value will be lost.

When we invoke Lir using `lir anagrams.lir` or `make` using the
[[<<Makefile>>]] defined above, Lir performs three steps in simple
succession:

1. "Tangle" the Lir source file;
2. "Make" everything;
3. "Weave" the final document.

The three steps are implemented as calls to the `lir` command line
program with the command `tangle`, `make`, or `weave` as the first
argument and the Lir source file name as the second argument.

## Tangle
Now, run the first step only:

<<: Tangle the source file>>=
$ lir tangle anagrams.lir
@

... and look inside the `.lir` folder. This is what I see:

<<: Contents of the .lir folder after tangling>>=
$ ls -a .lir
.                 __LIR_SOURCE_anagrams.lir  .makehtml
..                .makeall                   to-lower-case.prolog
clean-en-dict.sh  .makedag
en-dict           Makefile
@

Here is how these files came to be, and why they are there (note the use
of a `#.` for autonumbered bullet points):

#.  Before anything else, Lir creates the `.lir` directory if it does not
    yet exist.

#.  Lir looks for executable programs in your Lir source file.  All root code
    chunks that are not special code chunks (name does not begin with a
    colon) are extracted to files inside `.lir`.  The file names are the code
    chunk names: for now, we see `clean-dict-en-dict.sh` and
    `to-lower-case.prolog` listed there.  You can open these in your text
    editor: go ahead and do it!

#.  Lir generates three makefiles in `.lir`: `.makeall`, `.makedag`, and
    `.makehtml`.  Look at them in your text editor!

    The file `.makeall` contains a rule that lists all
    input files declared in the Lir source file as prerequisites for
    making the target `all`.

    The file `.makedag` is a concatenation of all the [[<<:make>>]] code chunks
    defined in the Lir source file.

    The file `.makehtml` contains the rule for generating the final
    document.

#.  Lir generates a normalized version of the Lir source file.  The name
    of this normalized version is prefixed by `__LIR_SOURCE_`.  If you
    are really ambitious, go ahead and use `diff` to see how the
    normalized version is different from the original Lir source.

At this point, Lir has created a "state" for the work flow: it has
tangled all executable code so that it can be evaluated, and generated
makefiles so that code can be evaluated while observing the dependencies
in the work flow.

## Make
To evaluate the state, run the second step (don't forget to change back
to the working directory):

<<: Make all results>>=
$ lir make anagrams.lir
@

You should see that the two programs are evaluated: first,
`clean-dict-sh` cleans `en-dict` to obtain `en-words`; then, `wc` is
used to show the size of both `en-dict` and `en-words`, and saves the
output to `en-sizes`.

You can look for the files `en-words` and `en-sizes` inside `.lir`.  At
the moment, those are all the results generated by the work flow.

## Weave
To generate the final document, run the last step:
<<: Weave the final document>>=
$ lir weave anagrams.lir
@

The final HTML document is generated and copied from `.lir` to the
working directory.  You can open it in your web browser (as you have
been doing all along).

There is a practical advantage of running the three steps -- Tangle,
Make, and Weave -- separately.  The second step, Make, can be run on a
different machine: for example, a server with enough memory to handle
large data sets.  To do that, one would only have to copy the state
(the `.lir` directory) to the remote server, run `make` there, and then
copy the state with all generated results back to the local machine
for Weaving.
